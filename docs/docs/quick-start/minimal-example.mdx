---
sidebar_position: 2
---

import AuthorDetails from '@site/src/components/AuthorDetails';

# Minimal Working Example

In this post, we walk you through a minimal working example using the DSPy library. 

We make use of the [MATH dataset](https://huggingface.co/datasets/hendrycks/competition_math) and the OpenAI `gpt-4o-mini` model to simulate prompting tasks within DSPy.

## Setup

Before we jump into the example, let's ensure our environment is properly configured. We'll start by importing the necessary data to DSPy Format and configuring our language model:

```python
import dspy
import random
import openai

from dspy.datasets import DataLoader

# Set up the LM.
lm = dspy.LM(model='openai/gpt-4o-mini', max_tokens=1200)
dspy.configure(lm=lm)

# Load math questions from the MATH dataset using `DataLoader`
dl = DataLoader()

math = dl.from_huggingface(
    "hendrycks/competition_math",
    input_keys=("problem", )
)

random.seed(84)
math_trainset, math_valset, math_devset = (
    random.sample(math['train'], 20), 
    random.sample(math['train'], 30), 
    random.sample(math['train'], 50)
)
```

Let's take a look at what `math_trainset` and `math_devset` are:

```python
print(math_trainset)
```

The `math_trainset` and `math_devset` datasets contain lists of `dspy.Examples`, with each example having `problem` and `solution` fields.

## Define the Module

With our environment set up, let's define a custom program that utilizes the [`ChainOfThought`](/docs/deep-dive/modules/ChainOfThought) module to perform step-by-step reasoning to generate answers:

```python
cot = dspy.ChainOfThought("problem -> solution")
```

You can execute this module by passing `problem` as parameter to the call directly:

```python
cot(problem=math_devset[-1].problem)
```

**Output:**
```
Prediction(
    reasoning='To factor the polynomial \\( x^{10} + x^5 + 1 \\), we can utilize the roots of unity. Specifically, we can let \\( \\omega \\) be a primitive cube root of unity, satisfying the equation \\( \\omega^3 = 1 \\) and \\( \\omega^2 + \\omega + 1 = 0 \\). By substituting \\( \\omega \\) into the polynomial, we find that \\( \\omega^{10} + \\omega^5 + 1 = 0 \\), indicating that \\( x^2 + x + 1 \\) is a factor of \\( x^{10} + x^5 + 1 \\).\n\nNext, we can express \\( x^{10} + x^5 + 1 \\) in a form that reveals its factors. We rewrite the polynomial by grouping terms and factoring out common factors. After some algebraic manipulation, we arrive at the factorization:\n\n\\[\nx^{10} + x^5 + 1 = (x^2 + x + 1)(x^8 - x^7 + x^5 - x^4 + x^3 - x + 1).\n\\]\n\nThis shows that the polynomial can be expressed as the product of two polynomials with integer coefficients.',
    answer='The factorization of \\( x^{10} + x^5 + 1 \\) is \\( (x^2 + x + 1)(x^8 - x^7 + x^5 - x^4 + x^3 - x + 1) \\).'
)
```

You can see the prompt along with completion for this call using `inspect_history` method:

```python
lm.inspect_history(n=1)
```

**Output:**
```
System message:

Your input fields are:
1. `problem` (str)

Your output fields are:
1. `reasoning` (str)
2. `answer` (str)

All interactions will be structured in the following way, with the appropriate values filled in.

[[ ## problem ## ]]
{problem}

[[ ## reasoning ## ]]
{reasoning}

[[ ## answer ## ]]
{answer}

[[ ## completed ## ]]

In adhering to this structure, your objective is: 
        Given the fields `problem`, produce the fields `answer`.


User message:

[[ ## problem ## ]]
Write $x^{10} + x^5 + 1$ as the product of two polynomials with integer coefficients.

Response:

[[ ## reasoning ## ]]
To factor the polynomial \( x^{10} + x^5 + 1 \), we can utilize the roots of unity. Specifically, we can let \( \omega \) be a primitive cube root of unity, satisfying the equation \( \omega^3 = 1 \) and \( \omega^2 + \omega + 1 = 0 \). By substituting \( \omega \) into the polynomial, we find that \( \omega^{10} + \omega^5 + 1 = 0 \), indicating that \( x^2 + x + 1 \) is a factor of \( x^{10} + x^5 + 1 \).

...

[[ ## answer ## ]]
The factorization of \( x^{10} + x^5 + 1 \) is \( (x^2 + x + 1)(x^8 - x^7 + x^5 - x^4 + x^3 - x + 1) \).

[[ ## completed ## ]]
```

In the prompt above there are 3 fields. The `System Message` contains the formatting information of the module, while the `User Message` contains the input question. The `Response` contains the output generated by the model.

## Compile and Evaluate the Model

With our simple program in place, let's move on to compiling it with the [`MIPROv2`](/docs/deep-dive/optimizers/miprov2.md) teleprompter:

```python
tp = dspy.MIPROv2(
    metric=math_metric, 
    num_candidates=5, 
    init_temperature=0.7, 
    verbose=False, 
    num_threads=4
)
compiled_cot = tp.compile(
    CoT(), trainset=math_trainset, 
    valset=math_valset, 
    max_bootstrapped_demos=3, 
    max_labeled_demos=3, 
    num_trials=15, 
    requires_permission_to_run=False
)
```

This should take ~10-15 minutes to complete which you can speed but by increasing the `num_threads` parameter but be careful to not overflow the rate limits of API. To check the cost of optimization you can execute the following:

```python
print(f"Optimization Cost: {sum([lm.history[i]['cost'] for i in range(len(lm.history))])}")
```

`lm.history` stores the history of your model's interactions, including the cost of each interaction. We can just sum the cost of these interaction and get the total cost of optimization, which is ~26 cents.

:::note
Make sure that you clear the `lm.history` using `lm.history.clear()` before doing the optimization to get the accurate cost. This is especial
:::

## Evaluate

Now that we have a compiled (optimized) DSPy program, let's move to evaluating its performance and compare it with the unoptimized model on `math_devset`. Before that, we need a metric to score the solutions. For MATH dataset, it's a bit hard to create a quantitative that works on exact answer/term match. Luckily we can create an LLM judge fairly easily with DSPy:

```python
llm_judge = dspy.ChainOfThought("question, reference_solution, student_solution -> correct: bool")

def math_metric(gold, pred, trace=None):
  return llm_judge(question=gold.problem, reference_solution=gold.solution, student_solution=pred.answer).correct
```

With the metric in place, we can now evaluate the performance of our unoptimized and optimizer models using the `Evaluate` class:

```python
from dspy.evaluate import Evaluate

# Set up the evaluator, which can be used multiple times.
evaluate = Evaluate(
    devset=math_devset, 
    metric=math_metric, 
    num_threads=4, 
    display_progress=True, 
    display_table=0
)

# Evaluate our `optimized_cot` program.
print(f"Unoptimized Model Score: {evaluate(CoT())}")
print(f"Optimized Model Score: {evaluate(compiled_cot)}")
```

**Output:**
```
Unoptimized Model Score: 70.0
Optimized Model Score: 76.0
```

That's a fairly decent boost with a vanilla CoT pipeline and relatively limited training/ testing dataset!!

:::note
MATH a popular task that the models are directly optimized for resulting in a relatively low gain, however gains are typically larger for harder tasks.
:::

## Inspect the Model's History

For understanding the `compiled_cot` module's interactions, we can review the most recent generations through inspecting the model's history:

```python
compiled_cot(problem=math_devset[-1].problem)
dspy.inspect_history(n=1)  # or lm.inspect_history(n=1)
```

**Output:**
```
System message:

Your input fields are:
1. `problem` (str)

Your output fields are:
1. `reasoning` (str)
2. `answer` (str)

All interactions will be structured in the following way, with the appropriate values filled in.

[[ ## problem ## ]]
{problem}

[[ ## reasoning ## ]]
{reasoning}

[[ ## answer ## ]]
{answer}

[[ ## completed ## ]]

In adhering to this structure, your objective is: 
        Analyze the given mathematical problem related to quadratic functions, and provide a detailed step-by-step reasoning process that leads to the final answer. Ensure that your explanation includes identifying key components like coefficients, roots, and the vertex of the parabola, and culminate with the final result based on your analysis.


User message:

[[ ## problem ## ]]
Example({'problem': 'Write $x^{10} + x^5 + 1$ as the product of two polynomials with integer coefficients.', 'level': 'Level 5', 'type': 'Intermediate Algebra', 'solution': 'Let $\\omega$ satisfy $x^2 + x + 1 = 0,$ so $\\omega^2 + \\omega + 1 = 0.$  Then $(\\omega - 1)(\\omega^2 + \\omega + 1) = \\omega^3 - 1 = 0,$ so $\\omega^3 = 1.$  Also,\n\\begin{align*}\n\\omega^{10} + \\omega^5 + 1 &= \\omega^9 \\cdot \\omega + \\omega^3 \\cdot \\omega^2 + 1 \\\\\n&= \\omega + \\omega^2 + 1 \\\\\n&= 0.\n\\end{align*}Therefore, $x^2 + x + 1$ is a factor of $x^{10} + x^5 + 1.$\n\nTo bring out this factorization, we can write\n\\begin{align*}\nx^{10} + x^5 + 1 &= x^{10} - x + x^5 - x^2 + x^2 + x + 1 \\\\\n&= x(x^9 - 1) + x^2 (x^3 - 1) + x^2 + x + 1 \\\\\n&= x(x^3 - 1)(x^6 + x^3 + 1) + x^2 (x - 1)(x^2 + x + 1) + x^2 + x + 1 \\\\\n&= x(x - 1)(x^2 + x + 1)(x^6 + x^3 + 1) + x^2 (x - 1)(x^2 + x + 1) + x^2 + x + 1 \\\\\n&= \\boxed{(x^2 + x + 1)(x^8 - x^7 + x^5 - x^4 + x^3 - x + 1)}.\n\\end{align*}'}) (input_keys={'problem'})

Respond with the corresponding output fields, starting with the field `reasoning`, then `answer`, and then ending with the marker for `completed`.


Response:

[[ ## reasoning ## ]]
To factor the polynomial \( x^{10} + x^5 + 1 \), we can utilize the roots of unity. We start by letting \( \omega \) be a primitive cube root of unity, satisfying the equation \( \omega^3 = 1 \) and \( \omega^2 + \omega + 1 = 0 \). 

...

[[ ## answer ## ]]
The factorization of \( x^{10} + x^5 + 1 \) is \( (x^2 + x + 1)(x^8 - x^7 + x^5 - x^4 + x^3 - x + 1) \).

[[ ## completed ## ]]
```

If you see the objective in the above prompt is now modified to an optimal objective from the optimizer. And there you have it! You've successfully created a working example using the DSPy library. 

This example showcases how to set up your environment, define a custom module, compile a model, and rigorously evaluate its performance using the provided dataset and teleprompter configurations. 

Feel free to adapt and expand upon this example to suit your specific use case while exploring the extensive capabilities of DSPy.

If you want to try what you just built, run `optimized_cot(question='Your Question Here')`.

:::note
For a more comprehensive walkthrough with detailed examples, please refer to the introduction colab: [<img align="center" src="https://colab.research.google.com/assets/colab-badge.svg" />](https://colab.research.google.com/github/stanfordnlp/dspy/blob/main/intro.ipynb).
:::

***

<AuthorDetails name="Herumb Shandilya"/>
